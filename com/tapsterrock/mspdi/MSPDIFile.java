/*
 * file:       MSPDIFile.java
 * author:     Jon Iles
 * copyright:  (c) Tapster Rock Limited 2002-2003
 * date:       20/02/2003
 */

/*
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
 */

package com.tapsterrock.mspdi;

import com.tapsterrock.mpx.AccrueType;
import com.tapsterrock.mpx.BaseCalendar;
import com.tapsterrock.mpx.BaseCalendarException;
import com.tapsterrock.mpx.BaseCalendarHours;
import com.tapsterrock.mpx.ConstraintType;
import com.tapsterrock.mpx.CurrencySettings;
import com.tapsterrock.mpx.DateTimeSettings;
import com.tapsterrock.mpx.DefaultSettings;
import com.tapsterrock.mpx.MPXDuration;
import com.tapsterrock.mpx.MPXException;
import com.tapsterrock.mpx.MPXFile;
import com.tapsterrock.mpx.MPXRate;
import com.tapsterrock.mpx.Task;
import com.tapsterrock.mpx.TimeUnit;
import com.tapsterrock.mpx.Priority;
import com.tapsterrock.mpx.ProjectHeader;
import com.tapsterrock.mpx.Relation;
import com.tapsterrock.mpx.RelationList;
import com.tapsterrock.mpx.Resource;
import com.tapsterrock.mpx.ResourceAssignment;
import com.tapsterrock.mspdi.schema.ObjectFactory;
import com.tapsterrock.mspdi.schema.Project;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.math.BigInteger;
import java.math.BigDecimal;
import java.net.URL;
import java.util.Date;
import java.util.Calendar;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.TreeSet;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;
import javax.xml.bind.Unmarshaller;

/**
 * This class is used to represent a Microsoft Project Data Interchange
 * (MSPDI) XML file. This implementation allows the file to be read,
 * and the data it contains exported as a set of MPX objects.
 * These objects can be interrogated to retrieve any required data,
 * or stored as an MPX file.
 */
public class MSPDIFile extends MPXFile
{
	/**
	 * This constructor allows a new MSPDI file to be created from scratch.
	 * 
	 * @throws MPXException Normally thrown on data format errors.
	 */	
	public MSPDIFile ()
		throws MPXException
	{
		super ();
	}
	
   /**
    * Copy constructor. WARNING: this provides a shallow copy only.
    * This allows a "generic" MPX file to be "specialised" as an MSPDI
    * file. The contents of the file can then be written out as XML
    * data rather than as MPX data.
    *
    * @param file File to be copied
    */
   public MSPDIFile (MPXFile file)
   {
      super (file);
   }

   /**
    * Constructor allowing an MSPDI file to be read from an input stream
    *
    * @param stream an input stream
    * @throws MPXException on file read errors
    */
   public MSPDIFile (InputStream stream)
      throws MPXException
   {
      read (stream);
   }

   /**
    * Constructor allowing an MSPDI file to be read from a file object.
    *
    * @param file File object
    * @throws MPXException on file read errors
    */
   public MSPDIFile (File file)
      throws MPXException
   {
      read (file);
   }

   /**
    * Constructor allowing an MSPDI file to be read from a named file.
    *
    * @param filename File name
    * @throws MPXException on file read errors
    */
   public MSPDIFile (String filename)
      throws MPXException
   {
      read (new File (filename));
   }

   /**
    * This method is used to set a flag that determines whether
    * XML generated by this class is adjusted to be compatible with
    * Microsoft Project 2002.
    *
    * @param flag Compatibility flag
    */
   public void setMicrosoftProjectCompatibleOutput (boolean flag)
   {
      m_compatible = true;
   }

   /**
    * This method retrieves a flag indicating whether the XML
    * output by this clas is compatible with Microsoft Project 2002.
    *
    * @return Boolean flag
    */
   public boolean getMicrosoftProjectCompatibleOutput ()
   {
      return (m_compatible);
   }

   /**
    * This method implements reading from a named file, and
    * maps any exceptions thrown into an MPXException.
    *
    * @param file file name
    * @throws MPXException on file read errors
    */
   public void read (String file)
     throws MPXException
   {
      try
      {
         FileInputStream fis = new FileInputStream (file);
         read (fis);
         fis.close();
      }

      catch (IOException ex)
      {
         throw new MPXException (MPXException.READ_ERROR, ex);
      }
   }

   /**
    * This method implements reading from a File object and
    * maps any exceptions thrown into an MPXException.
    *
    * @param file File object
    * @throws MPXException on file read errors
    */
   public void read (File file)
     throws MPXException
   {
      try
      {
         FileInputStream fis = new FileInputStream (file);
         read (fis);
         fis.close();
      }

      catch (IOException ex)
      {
         throw new MPXException (MPXException.READ_ERROR, ex);
      }
   }

   /**
    * This method brings together all of the processing required to
    * extract data from an MSPDI file and populate the MPX data structures.
    *
    * @param stream Input stream
    * @throws MPXException on file read errors
    */
   public void read (InputStream stream)
      throws MPXException
   {
      try
      {
         //
         // Note that the line commented out below is the normal way to
         // initialise the context. A workaround has been applied to this
         // code to solve a problem in Sun's Beta 1.0 Reference Implementation
         // of JAXB. See the URL below for details.
         //
         // http://forum.java.sun.com/thread.jsp?forum=34&thread=320813
         //

         //JAXBContext context = JAXBContext.newInstance ("com.tapsterrock.mspdi.schema");
         JAXBContext context = JAXBContext.newInstance ("com.tapsterrock.mspdi.schema", new JAXBClassLoader(Thread.currentThread().getContextClassLoader()));

         Unmarshaller unmarshaller = context.createUnmarshaller ();
         Project project = (Project)unmarshaller.unmarshal (stream);
         HashMap calendarMap = new HashMap ();

         readCurrencySettings (project);
         readDateTimeSettings (project);
         readDefaultSettings (project);
         readProjectHeader (project);
         readCalendars (project, calendarMap);
         readResources (project, calendarMap);
         readTasks (project);
         readAssignments (project);
      }

      catch (JAXBException ex)
      {
         throw new MPXException ("Failed to parse file", ex);
      }
   }

   /**
    * This method extracts currency settings data from an MSPDI file.
    *
    * @param project Root node of the MSPDI file
    */
   private void readCurrencySettings (Project project)
   {
      CurrencySettings currency = getCurrencySettings();
      currency.setCurrencyDigits (getInteger(project.getCurrencyDigits()));
      currency.setCurrencySymbol (project.getCurrencySymbol());
      //currency.setDecimalSeparator ();
      currency.setSymbolPosition (getMpxSymbolPosition(project.getCurrencySymbolPosition()));
      //currency.setThousandsSeparator ();
   }

   /**
    * This method extracts date and time settings data from an MSPDI file.
    *
    * @param project Root node of the MSPDI file
    */
   private void readDateTimeSettings (Project project)
   {
      DateTimeSettings settings = getDateTimeSettings();
      //settings.setAMText();
      //settings.setBarTextDateFormat();
      //settings.setDateFormat();
      //settings.setDateOrder();
      //settings.setDateSeparator();
      settings.setDefaultEndTime(getDate(project.getDefaultFinishTime()));
      settings.setDefaultStartTime(getDate(project.getDefaultStartTime()));
      //settings.setPMText();
      //settings.setTimeFormat();
      //settings.setTimeSeparator();
   }


   /**
    * This method extracts default settings data from an MSPDI file.
    *
    * @param project Root node of the MSPDI file
    */
   private void readDefaultSettings (Project project)
   {
      DefaultSettings settings = getDefaultSettings();

      //settings.setDefaultDurationIsFixed();
      settings.setDefaultDurationUnits(getMpxDurationUnits(project.getDurationFormat()));
      //settings.setDefaultHoursInDay();
      //settings.setDefaultHoursInWeek();
      // The default overtime rate always seems to be specified in hours
      settings.setDefaultOvertimeRate(new MPXRate(project.getDefaultOvertimeRate(), TimeUnit.HOURS));
      settings.setDefaultStandardRate(new MPXRate(project.getDefaultStandardRate(), TimeUnit.HOURS));
      settings.setDefaultWorkUnits(getMpxWorkUnits (project.getWorkFormat()));
      settings.setSplitInProgressTasks(project.isSplitsInProgressTasks());
      settings.setUpdatingTaskStatusUpdatesResourceStatus(project.isTaskUpdatesResource());
   }

   /**
    * This method extracts project header data from an MSPDI file.
    *
    * @param project Root node of the MSPDI file
    */
   private void readProjectHeader (Project project)
   {
      ProjectHeader header = getProjectHeader ();
      //header.setActualCost();
      //header.setActualDuration();
      //header.setActualFinish();
      //header.setActualStart();
      //header.setActualWork();
      header.setAuthor(project.getAuthor());
      //header.setBaselineCost();
      //header.setBaselineDuration();
      //header.setBaselineFinish();
      //header.setBaselineStart();
      //header.setBaselineWork();
      //header.setCalendar();
      //header.setComments();
      header.setCompany(project.getCompany());
      //header.setCost();
      header.setCurrentDate(getDate (project.getCurrentDate()));
      //header.setDuration();
      header.setFinishDate(getDate (project.getFinishDate()));
      //header.setFinishVariance();
      //header.setKeywords();
      header.setManager(project.getManager());
      //header.setPercentageComplete();
      //header.setProjectTab();
      //header.setScheduleFrom();
      header.setStartDate(getDate (project.getStartDate()));
      //header.setStartVariance();
      header.setSubject(project.getSubject());
      //header.setWork();
      //header.setWork2();
   }

   /**
    * This method extracts calandar data from an MSPDI file.
    *
    * @param project Root node of the MSPDI file
    * @param map Map of calendar UIDs to names
    * @throws MPXException on file read errors
    */
   private void readCalendars (Project project, HashMap map)
      throws MPXException
   {
      Project.CalendarsType calendars = project.getCalendars();
      if (calendars != null)
      {
         List calendar = calendars.getCalendar();
         Iterator iter = calendar.iterator();

         while (iter.hasNext() == true)
         {
            readCalendar ((Project.CalendarsType.CalendarType)iter.next(), map);
         }
      }
   }

   /**
    * This method extracts data for a single calandar from an MSPDI file.
    *
    * @param calendar Calendar data
    * @param map Map of calendar UIDs to names
    * @throws MPXException on file read errors
    */
   private void readCalendar (Project.CalendarsType.CalendarType calendar, HashMap map)
      throws MPXException
   {
      BaseCalendar bc;
      Iterator iter;

      bc = addBaseCalendar();
      bc.setName(calendar.getName());

      Project.CalendarsType.CalendarType.WeekDaysType days = calendar.getWeekDays();
      if (days != null)
      {
         List day = days.getWeekDay();
         iter = day.iterator();

         while (iter.hasNext() == true)
         {
            readDay (bc, (Project.CalendarsType.CalendarType.WeekDaysType.WeekDayType)iter.next());
         }
      }

      map.put(calendar.getBaseCalendarUID(), bc.getName());
   }

   /**
    * This method extracts data for a single day from an MSPDI file.
    *
    * @param calendar Calendar data
    * @param day Day data
    * @throws MPXException on file read errors
    */
   private void readDay (BaseCalendar calendar, Project.CalendarsType.CalendarType.WeekDaysType.WeekDayType day)
      throws MPXException
   {
      BigInteger dayType = day.getDayType();
      if (dayType != null)
      {
         if (dayType.intValue() == 0)
         {
            readExceptionDay (calendar, day);
         }
         else
         {
            readNormalDay (calendar, day);
         }
      }
   }

   /**
    * This method extracts data for a normal working day from an MSPDI file.
    *
    * @param calendar Calendar data
    * @param day Day data
    * @throws MPXException on file read errors
    */
   private void readNormalDay (BaseCalendar calendar, Project.CalendarsType.CalendarType.WeekDaysType.WeekDayType day)
      throws MPXException
   {
      int dayNumber = day.getDayType().intValue() + 1;
      if (dayNumber == 8)
      {
         dayNumber = 1;
      }

      calendar.setWorkingDay(dayNumber, day.isDayWorking());
      BaseCalendarHours hours = calendar.addBaseCalendarHours(dayNumber);

      Project.CalendarsType.CalendarType.WeekDaysType.WeekDayType.WorkingTimesType times = day.getWorkingTimes();
      if (times != null)
      {
         Project.CalendarsType.CalendarType.WeekDaysType.WeekDayType.WorkingTimesType.WorkingTimeType period;
         List time = times.getWorkingTime();
         Iterator iter = time.iterator();

         if (iter.hasNext() == true)
         {
            period = (Project.CalendarsType.CalendarType.WeekDaysType.WeekDayType.WorkingTimesType.WorkingTimeType)iter.next();
            hours.setFromTime1(getDate(period.getFromTime()));
            hours.setToTime1(getDate(period.getToTime()));
         }

         if (iter.hasNext() == true)
         {
            period = (Project.CalendarsType.CalendarType.WeekDaysType.WeekDayType.WorkingTimesType.WorkingTimeType)iter.next();
            hours.setFromTime2(getDate(period.getFromTime()));
            hours.setToTime2(getDate(period.getToTime()));
         }

         if (iter.hasNext() == true)
         {
            period = (Project.CalendarsType.CalendarType.WeekDaysType.WeekDayType.WorkingTimesType.WorkingTimeType)iter.next();
            hours.setFromTime3(getDate(period.getFromTime()));
            hours.setToTime3(getDate(period.getToTime()));
         }
      }
   }


   /**
    * This method extracts data for an exception day from an MSPDI file.
    *
    * @param calendar Calendar data
    * @param day Day data
    * @throws MPXException on file read errors
    */
   private void readExceptionDay (BaseCalendar calendar, Project.CalendarsType.CalendarType.WeekDaysType.WeekDayType day)
      throws MPXException
   {
      BaseCalendarException exception = calendar.addBaseCalendarException();

      Project.CalendarsType.CalendarType.WeekDaysType.WeekDayType.TimePeriodType timePeriod = day.getTimePeriod();
      exception.setFromDate(getDate(timePeriod.getFromDate()));
      exception.setToDate(getDate(timePeriod.getToDate()));

      Project.CalendarsType.CalendarType.WeekDaysType.WeekDayType.WorkingTimesType times = day.getWorkingTimes();
      if (times != null)
      {
         Project.CalendarsType.CalendarType.WeekDaysType.WeekDayType.WorkingTimesType.WorkingTimeType period;
         List time = times.getWorkingTime();
         Iterator iter = time.iterator();

         if (iter.hasNext() == true)
         {
            period = (Project.CalendarsType.CalendarType.WeekDaysType.WeekDayType.WorkingTimesType.WorkingTimeType)iter.next();
            exception.setFromTime1(getDate(period.getFromTime()));
            exception.setToTime1(getDate(period.getToTime()));
         }

         if (iter.hasNext() == true)
         {
            period = (Project.CalendarsType.CalendarType.WeekDaysType.WeekDayType.WorkingTimesType.WorkingTimeType)iter.next();
            exception.setFromTime2(getDate(period.getFromTime()));
            exception.setToTime2(getDate(period.getToTime()));
         }

         if (iter.hasNext() == true)
         {
            period = (Project.CalendarsType.CalendarType.WeekDaysType.WeekDayType.WorkingTimesType.WorkingTimeType)iter.next();
            exception.setFromTime3(getDate(period.getFromTime()));
            exception.setToTime3(getDate(period.getToTime()));
         }
      }
   }

   /**
    * This method extracts resource data from an MSPDI file.
    *
    * @param project Root node of the MSPDI file
    * @param calendarMap Map of calendar UIDs to names
    * @throws MPXException on file read errors
    */
   private void readResources (Project project, HashMap calendarMap)
      throws MPXException
   {
      Project.ResourcesType resources = project.getResources();
      if (resources != null)
      {
         List resource = resources.getResource();
         Iterator iter = resource.iterator();
         while (iter.hasNext() == true)
         {
            readResource ((Project.ResourcesType.ResourceType)iter.next(), calendarMap);
         }
      }
   }

   /**
    * This method extracts data for a single resource from an MSPDI file.
    *
    * @param resource Resource data
    * @param calendarMap Map of calendar UIDs to names
    * @throws MPXException on file read errors
    */
   private void readResource (Project.ResourcesType.ResourceType resource, HashMap calendarMap)
      throws MPXException
   {
      Resource mpx = addResource();

      mpx.setAccrueAt(AccrueType.getInstance(resource.getAccrueAt()));
      mpx.setActualCost(getMpxCurrency(resource.getActualCost()));
      mpx.setActualOvertimeCost(getMpxCurrency(resource.getActualOvertimeCost()));      
      mpx.setActualWork(getDuration (resource.getActualWork()));
      mpx.setBaseCalendar ((String)calendarMap.get(resource.getCalendarUID()));
      //mpx.setBaselineCost();
      //mpx.setBaselineWork();
      mpx.setCode(resource.getCode());
      mpx.setCost(getMpxCurrency(resource.getCost()));
      mpx.setCostPerUse(getMpxCurrency(resource.getCostPerUse()));
      mpx.setCostVariance(resource.getCostVariance()/100);
      mpx.setEmailAddress(resource.getEmailAddress());
      mpx.setGroup(resource.getGroup());
      mpx.setID(getInteger(resource.getID()));
      mpx.setInitials(resource.getInitials());
      //mpx.setLinkedFields();
      mpx.setMaxUnits(resource.getMaxUnits()*100);
      mpx.setName(resource.getName());
      mpx.setNotes(resource.getNotes());
      //mpx.setObjects();
      //mpx.setOverallocated();
      mpx.setOvertimeCost(getMpxCurrency(resource.getOvertimeCost()));      
      mpx.setOvertimeRate(getHourlyRate(resource.getOvertimeRate()));
      mpx.setOvertimeWork(getDuration (resource.getOvertimeWork()));
      mpx.setPeak(resource.getPeakUnits() * 100);
      mpx.setPercentageWorkComplete(resource.getPercentWorkComplete());
      mpx.setRegularWork(getDuration(resource.getRegularWork()));      
      mpx.setRemainingCost(getMpxCurrency(resource.getRemainingCost()));
      mpx.setRemainingOvertimeCost(getMpxCurrency(resource.getRemainingOvertimeCost()));      
      mpx.setRemainingWork(getDuration (resource.getRemainingWork()));
      mpx.setStandardRate(getHourlyRate(resource.getStandardRate()));
      //mpx.setText1();
      //mpx.setText2();
      //mpx.setText3();
      //mpx.setText4();
      //mpx.setText5();
      mpx.setUniqueID(getInteger(resource.getUID()));
      mpx.setWork(getDuration (resource.getWork()));
      mpx.setWorkVariance(new MPXDuration (resource.getWorkVariance()/1000, TimeUnit.MINUTES));
   }


   /**
    * This method extracts task data from an MSPDI file.
    *
    * @param project Root node of the MSPDI file
    * @throws MPXException on file read errors
    */
   private void readTasks (Project project)
      throws MPXException
   {
      Project.TasksType tasks = project.getTasks();
      if (tasks != null)
      {
         List task = tasks.getTask();
         Iterator iter = task.iterator();
         while (iter.hasNext() == true)
         {
            readTask ((Project.TasksType.TaskType)iter.next());
         }

         iter = task.iterator();
         while (iter.hasNext() == true)
         {
            readPredecessors ((Project.TasksType.TaskType)iter.next());
         }
      }

      updateStructure ();
   }


   /**
    * This method extracts data for a single task from an MSPDI file.
    *
    * @param task Task data
    * @throws MPXException on file read errors
    */
   private void readTask (Project.TasksType.TaskType task)
      throws MPXException
   {
      Task mpx = addTask ();
		
      mpx.setActualCost(getMpxCurrency (task.getActualCost()));
      mpx.setActualDuration(getDuration (task.getActualDuration()));
      mpx.setActualFinish(getDate (task.getActualFinish()));
      mpx.setActualStart(getDate (task.getActualStart()));
      mpx.setActualWork(getDuration (task.getActualWork()));
      //mpx.setBaselineCost();
      //mpx.setBaselineDuration();
      //mpx.setBaselineFinish();
      //mpx.setBaselineStart();
      //mpx.setBaselineWork();
      //mpx.setBCWP();
      //mpx.setBCWS();
      //mpx.setConfirmed();
      mpx.setConstraintDate(getDate(task.getConstraintDate()));
      mpx.setConstraintType(ConstraintType.getInstance(task.getConstraintType()));
      mpx.setContact(task.getContact());
      mpx.setCost(getMpxCurrency(task.getCost()));
      //mpx.setCost1();
      //mpx.setCost2();
      //mpx.setCost3();
      //mpx.setCostVariance();
      mpx.setCreated(getDate(task.getCreateDate()));
      mpx.setCritical(task.isCritical());
      mpx.setCV(task.getCV()/100);
      mpx.setDeadline(getDate(task.getDeadline()));
      //mpx.setDelay();
      mpx.setDuration(getDuration (task.getDuration()));
      //mpx.setDuration1();
      //mpx.setDuration2();
      //mpx.setDuration3();
      //mpx.setDurationVariance();
      mpx.setEarlyFinish(getDate(task.getEarlyFinish()));
      mpx.setEarlyStart(getDate(task.getEarlyStart()));
      mpx.setEffortDriven(task.isEffortDriven());
      mpx.setEstimated(task.isEstimated());
      mpx.setFinish(getDate(task.getFinish()));
      //mpx.setFinish1();
      //mpx.setFinish2();
      //mpx.setFinish3();
      //mpx.setFinish4();
      //mpx.setFinish5();
      mpx.setFinishVariance(getMinutesDuration(task.getFinishVariance()));
      //mpx.setFixed();
      mpx.setFixedCost(task.getFixedCost()/100);
      //mpx.setFlag1();
      //mpx.setFlag2();
      //mpx.setFlag3();
      //mpx.setFlag4();
      //mpx.setFlag5();
      //mpx.setFlag6();
      //mpx.setFlag7();
      //mpx.setFlag8();
      //mpx.setFlag9();
      //mpx.setFlag10();
      mpx.setFreeSlack(getMinutesDuration(task.getFreeSlack()));
      //mpx.setHideBar();
      mpx.setID(getInteger(task.getID()));
      mpx.setLateFinish(getDate(task.getLateFinish()));
      mpx.setLateStart(getDate(task.getLateStart()));
      //mpx.setLinkedFields();
      //mpx.setMarked();
      mpx.setMilestone(task.isMilestone());
      mpx.setName(task.getName());
      mpx.setNotes(task.getNotes());
      //mpx.setNumber1();
      //mpx.setNumber2();
      //mpx.setNumber3();
      //mpx.setNumber4();
      //mpx.setNumber5();
      //mpx.setObjects();
      mpx.setOutlineLevel(getInteger(task.getOutlineLevel()));
      mpx.setOutlineNumber(task.getOutlineNumber());
      mpx.setOvertimeCost(getMpxCurrency(task.getOvertimeCost()));
      mpx.setPercentageComplete(task.getPercentComplete());
      mpx.setPercentageWorkComplete(task.getPercentWorkComplete());
      mpx.setPriority(getMpxPriority(task.getPriority()));
      //mpx.setProject();
      mpx.setRemainingCost(getMpxCurrency(task.getRemainingCost()));
      mpx.setRemainingDuration(getDuration(task.getRemainingDuration()));
      mpx.setRemainingWork(getDuration (task.getRemainingWork()));
      //mpx.setResourceGroup();
      //mpx.setResourceInitials();
      //mpx.setResourceNames();
      mpx.setResume(getDate(task.getResume()));
      //mpx.setResumeNoEarlierThan();
      mpx.setRollup(task.isRollup());
      mpx.setStart(getDate(task.getStart()));
      //mpx.setStart1();
      //mpx.setStart2();
      //mpx.setStart3();
      //mpx.setStart4();
      //mpx.setStart5();
      mpx.setStartVariance(getMinutesDuration(task.getStartVariance()));
      mpx.setStop(getDate(task.getStop()));
      //mpx.setSubprojectFile();
      //mpx.setSuccessors();
      mpx.setSummary(task.isSummary());
      //mpx.setSV();
      //mpx.setText1();
      //mpx.setText2();
      //mpx.setText3();
      //mpx.setText4();
      //mpx.setText5();
      //mpx.setText6();
      //mpx.setText7();
      //mpx.setText8();
      //mpx.setText9();
      //mpx.setText10();
      mpx.setTotalSlack(getMinutesDuration(task.getTotalSlack()));
      mpx.setType(getInteger(task.getType()).intValue());
      mpx.setUniqueID(getInteger(task.getUID()));
      //mpx.setUpdateNeeded();
      mpx.setWBS(task.getWBS());
      mpx.setWork(getDuration(task.getWork()));
      mpx.setWorkVariance(new MPXDuration (task.getWorkVariance()/1000, TimeUnit.MINUTES));
   }

   /**
    * This method extracts predecessor data from an MSPDI file.
    *
    * @param task Task data
    */
   private void readPredecessors (Project.TasksType.TaskType task)
   {
      BigInteger uid = task.getUID();
      if (uid != null)
      {
         Task currTask = getTaskByUniqueID(uid.intValue());
         if (currTask != null)
         {
            List predecessors = task.getPredecessorLink();
            Iterator iter = predecessors.iterator();

            while (iter.hasNext() == true)
            {
               readPredecessor (currTask, (Project.TasksType.TaskType.PredecessorLinkType)iter.next());
            }
         }
      }
   }

   /**
    * This method extracts data for a single predecessor from an MSPDI file.
    *
    * @param currTask Current task object
    * @param link Predecessor data
    */
   private void readPredecessor (Task currTask, Project.TasksType.TaskType.PredecessorLinkType link)
   {
      BigInteger uid = link.getPredecessorUID();
      if (uid != null)
      {
         Task prevTask = getTaskByUniqueID(uid.intValue());
         if (prevTask != null)
         {
            int type;
            if (link.getType() != null)
            {
               type = link.getType().intValue();
            }
            else
            {
               type = Relation.FINISH_START;
            }

            int lag;

            if (link.getLinkLag() != null)
            {
               lag = link.getLinkLag().intValue() / (10*60);
            }
            else
            {
               lag = 0;
            }

            Relation rel = currTask.addPredecessor(prevTask);
            rel.setType(type);
            rel.setDuration(new MPXDuration (lag, TimeUnit.HOURS));
         }
      }
   }

   /**
    * This method extracts assignment data from an MSPDI file.
    *
    * @param project Root node of the MSPDI file
    * @throws MPXException on file read errors
    */
   private void readAssignments (Project project)
      throws MPXException
   {
      Project.AssignmentsType assignments = project.getAssignments();
      if (assignments != null)
      {
         List assignment = assignments.getAssignment();
         Iterator iter = assignment.iterator();
         while (iter.hasNext() == true)
         {
            readAssignment ((Project.AssignmentsType.AssignmentType)iter.next());
         }
      }
   }


   /**
    * This method extracts data for a single assignment from an MSPDI file.
    *
    * @param assignment Assignment data
    * @throws MPXException on file read errors
    */
   private void readAssignment (Project.AssignmentsType.AssignmentType assignment)
      throws MPXException
   {
      BigInteger taskUID = assignment.getTaskUID();
      BigInteger resourceUID = assignment.getResourceUID();
      if (taskUID != null && resourceUID != null)
      {
         Task task = getTaskByUniqueID(taskUID.intValue());
         Resource resource = getResourceByUniqueID(resourceUID.intValue());

         if (task != null && resource != null)
         {
            ResourceAssignment mpx = task.addResourceAssignment(resource);
            mpx.setActualCost(getMpxCurrency(assignment.getActualCost()));
            mpx.setActualWork(getDuration(assignment.getActualWork()));
            mpx.setCost(getMpxCurrency(assignment.getCost()));
            mpx.setDelay(getMinutesDuration(assignment.getDelay()));
            mpx.setFinish(getDate(assignment.getFinish()));
            mpx.setOvertimeWork(getDuration(assignment.getOvertimeWork()));
            //mpx.setPlannedCost();
            //mpx.setPlannedWork();
            mpx.setStart(getDate(assignment.getStart()));
            mpx.setUnits(assignment.getUnits()*100);
            mpx.setWork(getDuration(assignment.getWork()));
         }
      }
   }

   /**
    * Utility method used to convert a BigInteger into an Integer.
    *
    * @param value BigInteger value
    * @return Integer value
    */
   private Integer getInteger (BigInteger value)
   {
      Integer result = null;

      if (value != null)
      {
         result = new Integer (value.intValue());
      }

      return (result);
   }

   /**
    * Utility to convert a Calendar instance into a Date instance.
    *
    * @param value Calendar value
    * @return Date value
    */
   private Date getDate (Calendar value)
   {
      Date result = null;

      if (value != null)
      {
         result = value.getTime ();
      }

      return (result);
   }

   /**
    * Utility to convert a Date instance into a Calendar instance.
    *
    * @param date Date value
    * @return Calendar value
    */
   private Calendar getCalendar (Date date)
   {
      Calendar cal = null;

      if (date != null)
      {
         cal = Calendar.getInstance();
         cal.setTime(date);
      }

      return (cal);
   }

   /**
    * Utility method to convert a BigInteger into
    * work units.
    *
    * @param value BigInteger value
    * @return work units
    */
   private int getMpxWorkUnits (BigInteger value)
   {
      int result = TimeUnit.HOURS;

      if (value != null)
      {
         switch (value.intValue())
         {
            case 1:
            {
               result = TimeUnit.MINUTES;
               break;
            }

            case 3:
            {
               result = TimeUnit.DAYS;
               break;
            }

            case 4:
            {
               result = TimeUnit.WEEKS;
               break;
            }

            case 5:
            {
               result = TimeUnit.MONTHS;
               break;
            }

            case 7:
            {
               result = TimeUnit.YEARS;
               break;
            }

            default:
            case 2:
            {
               result = TimeUnit.HOURS;
               break;
            }
         }
      }

      return (result);
   }

   /**
    * Utility method to convert a work units to a BigInteger value.
    *
    * @param value work units
    * @return BigInteger value
    */
   private BigInteger getXmlWorkUnits (int value)
   {
      int result;

      switch (value)
      {
         case TimeUnit.MINUTES:
         {
            result = 1;
            break;
         }

         case TimeUnit.DAYS:
         {
            result = 3;
            break;
         }

         case TimeUnit.WEEKS:
         {
            result = 4;
            break;
         }

         case TimeUnit.MONTHS:
         {
            result = 5;
            break;
         }

         case TimeUnit.YEARS:
         {
            result = 7;
            break;
         }

         default:
         case TimeUnit.HOURS:
         {
            result = 2;
            break;
         }
      }

      return (BigInteger.valueOf(result));
   }

   /**
    * Utility method to convert an xsd:duration into an MPXDuration.
    *
    * @param text xsd:duration value
    * @return MPXDuration
    */
   private MPXDuration getDuration (String text)
   {
      MPXDuration result = null;

      if (text != null && text.length() != 0)
      {
         XsdDuration xsd = new XsdDuration (text);
         int units = TimeUnit.DAYS;

         if (xsd.getSeconds() != 0 || xsd.getMinutes() != 0)
         {
            units = TimeUnit.MINUTES;
         }

         if (xsd.getHours() != 0)
         {
            units = TimeUnit.HOURS;
         }

         if (xsd.getDays() != 0)
         {
            units = TimeUnit.DAYS;
         }

         if (xsd.getMonths() != 0)
         {
            units = TimeUnit.MONTHS;
         }

         if (xsd.getYears() != 0)
         {
            units = TimeUnit.YEARS;
         }

         int duration = 0;

         switch (units)
         {
            case TimeUnit.YEARS:
            case TimeUnit.ELAPSED_YEARS:
            {
               duration += xsd.getYears();
               duration += (xsd.getMonths() / 12);
               duration += (xsd.getDays() / 365);
               duration += (xsd.getHours() / (365 * 24));
               duration += (xsd.getMinutes() / (365 * 24 * 60));
               duration += (xsd.getSeconds() / (365 * 24 * 60 * 60));
               break;
            }

            case TimeUnit.MONTHS:
            case TimeUnit.ELAPSED_MONTHS:
            {
               duration += (xsd.getYears() * 12);
               duration += xsd.getMonths();
               duration += (xsd.getDays() / 30);
               duration += (xsd.getHours() / (30 * 24));
               duration += (xsd.getMinutes() / (30 * 24 * 60));
               duration += (xsd.getSeconds() / (30 * 24 * 60 * 60));
               break;
            }

            case TimeUnit.WEEKS:
            case TimeUnit.ELAPSED_WEEKS:
            {
               duration += (xsd.getYears() * 52);
               duration += (xsd.getMonths() * 4);
               duration += (xsd.getDays() / 7);
               duration += (xsd.getHours() / (7 * 24));
               duration += (xsd.getMinutes() / (7 * 24 * 60));
               duration += (xsd.getSeconds() / (7 * 24 * 60 * 60));
               break;
            }

            case TimeUnit.DAYS:
            case TimeUnit.ELAPSED_DAYS:
            {
               duration += (xsd.getYears() * 365);
               duration += (xsd.getMonths() * 30);
               duration += xsd.getDays();
               duration += (xsd.getHours() / 24);
               duration += (xsd.getMinutes() / (24 * 60));
               duration += (xsd.getSeconds() / (24 * 60 * 60));
               break;
            }

            case TimeUnit.HOURS:
            case TimeUnit.ELAPSED_HOURS:
            {
               duration += (xsd.getYears() * (365 * 24));
               duration += (xsd.getMonths() * (30 * 24));
               duration += (xsd.getDays() * 24);
               duration += xsd.getHours();
               duration += (xsd.getMinutes() / 60);
               duration += (xsd.getSeconds() / (60 * 60));
               break;
            }

            case TimeUnit.MINUTES:
            case TimeUnit.ELAPSED_MINUTES:
            {
               duration += (xsd.getYears() * (365 * 24 * 60));
               duration += (xsd.getMonths() * (30 * 24 * 60));
               duration += (xsd.getDays() * (24 * 60));
               duration += (xsd.getHours() * 60);
               duration += xsd.getMinutes();
               duration += (xsd.getSeconds() / 60);
               break;
            }
         }

         result = new MPXDuration (duration, units);
      }

      return (result);
   }

   /**
    * Utility method to convert an MPXDuration into an xsd:duration.
    *
    * Note that Microsoft's xsd:duration parser implementation does not
    * appear to recognise durations other than those expressed in hours.
    * We use the compatibility flag to determine whether the output
    * is adjusted for the benefit of Microsoft Project.
    *
    * @todo The conversion from arbitrary durations to hours does not use a calendar
    * @param duration MPXDuration value
    * @return xsd:duration value
    */
   private String getDuration (MPXDuration duration)
   {
      String result = null;

      if (duration == null)
      {
         result = ZERO_DURATION;
      }
      else
      {
         if (m_compatible == false)
         {
            result = new XsdDuration(duration).toString();
         }
         else
         {
            double hours = duration.getDuration();

            switch (duration.getType())
            {
               case TimeUnit.MINUTES:
               case TimeUnit.ELAPSED_MINUTES:
               {
                  hours = duration.getDuration() / 60;
                  break;
               }

               case TimeUnit.DAYS:
               case TimeUnit.ELAPSED_DAYS:
               {
                  hours *= 8;
                  break;
               }

               case TimeUnit.WEEKS:
               case TimeUnit.ELAPSED_WEEKS:
               {
                  hours *= (8 * 5);
                  break;
               }

               case TimeUnit.MONTHS:
               case TimeUnit.ELAPSED_MONTHS:
               {
                  hours *= (8 * 5 * 4);
                  break;
               }

               case TimeUnit.YEARS:
               case TimeUnit.ELAPSED_YEARS:
               {
                  hours *= (8 * 5 * 52);
                  break;
               }
            }

            result = new XsdDuration(new MPXDuration (hours, TimeUnit.HOURS)).toString();
         }
      }

      return (result);
   }

   /**
    * Utility method to convert an MPXDuration into an xsd:duration.
    *
    * @param duration MPXDuration value
    * @return xsd:duration value
    */
   private BigInteger getDurationFormat (MPXDuration duration)
   {
      BigInteger result = null;

      if (duration != null)
      {
         result = getXmlDurationUnits(duration.getType());
      }

      return (result);
   }

   /**
    * Utility method to convert a BigInteger into a symbol position.
    *
    * @param position BigInteger position value
    * @return Symbol position
    */
   private int getMpxSymbolPosition (BigInteger position)
   {
      int result = CurrencySettings.SYMBOLPOS_BEFORE;

      if (position != null)
      {
         switch (position.intValue())
         {
            case 0:
            {
               result = CurrencySettings.SYMBOLPOS_BEFORE;
               break;
            }

            case 1:
            {
               result = CurrencySettings.SYMBOLPOS_AFTER;
               break;
            }

            case 2:
            {
               result = CurrencySettings.SYMBOLPOS_BEFORE_WITH_SPACE;
               break;
            }

            case 3:
            {
               result = CurrencySettings.SYMBOLPOS_AFTER_WITH_SPACE;
               break;
            }
         }
      }

      return (result);
   }


   /**
    * Utility method to convert a symbol position into a BigInteger.
    *
    * @param position symbol position
    * @return Symbol position
    */
   private BigInteger getXmlSymbolPosition (int position)
   {
      int result;

      switch (position)
      {
         default:
         case CurrencySettings.SYMBOLPOS_BEFORE:
         {
            result = 0;
            break;
         }

         case CurrencySettings.SYMBOLPOS_AFTER:
         {
            result = 1;
            break;
         }

         case CurrencySettings.SYMBOLPOS_BEFORE_WITH_SPACE:
         {
            result = 2;
            break;
         }

         case CurrencySettings.SYMBOLPOS_AFTER_WITH_SPACE:
         {
            result = 3;
            break;
         }
      }

      return (BigInteger.valueOf(result));
   }


   /**
    * Utility method to convert a BigDecimal into a currency value.
    *
    * @param value BigDecimal value
    * @return Currency value
    */
   private Double getMpxCurrency (BigDecimal value)
   {
      Double result = null;

      if (value != null)
      {
         result = new Double (value.doubleValue() / 100);
      }

      return (result);
   }

   /**
    * Utility method to convert a BigDecimal into a currency value.
    *
    * @param value Currency value
    * @return BigDecimal value
    */
   private BigDecimal getXmlCurrency (Number value)
   {
      BigDecimal result = null;

      if (value != null)
      {
         result = new BigDecimal (value.doubleValue() * 100);
      }
      else
      {
         result = BIGDECIMAL_ZERO;
      }

      return (result);
   }

   /**
    * Utility method to convert a BigInteger value into duration units.
    * Note that we don't differentiate between confirmed and unconfirmed
    * durations. Unrecognised duration types are default to hours.
    *
    * @param value BigInteger value
    * @return Duration units
    */
   private int getMpxDurationUnits (BigInteger value)
   {
      int result = TimeUnit.HOURS;

      if (value != null)
      {
         switch (value.intValue())
         {
            case 3:
            case 35:
            {
               result = TimeUnit.MINUTES;
               break;
            }

            case 4:
            case 36:
            {
               result = TimeUnit.ELAPSED_MINUTES;
               break;
            }

            case 5:
            case 37:
            {
               result = TimeUnit.HOURS;
               break;
            }

            case 6:
            case 38:
            {
               result = TimeUnit.ELAPSED_HOURS;
               break;
            }

            case 7:
            case 39:
            {
               result = TimeUnit.DAYS;
               break;
            }

            case 8:
            case 40:
            {
               result = TimeUnit.ELAPSED_DAYS;
               break;
            }

            case 9:
            case 41:
            {
               result = TimeUnit.WEEKS;
               break;
            }

            case 10:
            case 42:
            {
               result = TimeUnit.ELAPSED_WEEKS;
               break;
            }

            case 11:
            case 43:
            {
               result = TimeUnit.MONTHS;
               break;
            }

            case 12:
            case 44:
            {
               result = TimeUnit.ELAPSED_MONTHS;
               break;
            }

            case 19:
            case 51:
            {
               result = TimeUnit.PERCENT;
               break;
            }

            case 20:
            case 52:
            {
               result = TimeUnit.ELAPSED_PERCENT;
               break;
            }
         }
      }

      return (result);
   }


   /**
    * Utility method to convert duration units into a BigInteger value.
    * Note that we don't differentiate between confirmed and unconfirmed
    * durations. Unrecognised duration types are default to hours.
    *
    * @param value Duration units
    * @return BigInteger value
    */
   private BigInteger getXmlDurationUnits (int value)
   {
      int result;

      switch (value)
      {
         case TimeUnit.MINUTES:
         {
            result = 3;
            break;
         }

         case TimeUnit.ELAPSED_MINUTES:
         {
            result = 4;
            break;
         }

         case TimeUnit.ELAPSED_HOURS:
         {
            result = 6;
            break;
         }

         case TimeUnit.DAYS:
         {
            result = 7;
            break;
         }

         case TimeUnit.ELAPSED_DAYS:
         {
            result = 8;
            break;
         }

         case TimeUnit.WEEKS:
         {
            result = 9;
            break;
         }

         case TimeUnit.ELAPSED_WEEKS:
         {
            result = 10;
            break;
         }

         case TimeUnit.MONTHS:
         {
            result = 11;
            break;
         }

         case TimeUnit.ELAPSED_MONTHS:
         {
            result = 12;
            break;
         }

         case TimeUnit.PERCENT:
         {
            result = 19;
            break;
         }

         case TimeUnit.ELAPSED_PERCENT:
         {
            result = 20;
            break;
         }

         default:
         case TimeUnit.HOURS:
         {
            result = 5;
            break;
         }
      }

      return (BigInteger.valueOf(result));
   }


   /**
    * Utility method to convert a BigInteger value
    * into a priority.
    *
    * @param priority BigInteger value
    * @return Priority value
    */
   private Priority getMpxPriority (BigInteger priority)
   {
      int result = Priority.MEDIUM;

      if (priority != null)
      {
         if (priority.intValue() >= 1000)
         {
            result = Priority.DO_NOT_LEVEL;
         }
         else
         {
            result = (priority.intValue() / 100)-1;
         }
      }

      return (Priority.getInstance (result));
   }

   /**
    * Utility method to convert a priority into a BigInteger value.
    *
    * @param priority Priority value
    * @return BigInteger value
    */
   private BigInteger getXmlPriority (Priority priority)
   {
      int result = Priority.MEDIUM;

      if (priority != null)
      {
         result = (priority.getPriority()+1) * 100;
      }

      return (BigInteger.valueOf(result));
   }

   /**
    * Utility method to convert a duration expressed in minutes * 1000
    * as a BigInteger into an MPXDuration.
    *
    * @param value BigInteger value
    * @return MPXDuration
    */
   private MPXDuration getMinutesDuration (BigInteger value)
   {
      MPXDuration result = null;

      if (value != null)
      {
         result = new MPXDuration (value.intValue()/1000, TimeUnit.MINUTES);
      }

      return (result);
   }

   /**
    * This method retrieves the cost component of a rate and handles
    * the case where the rate is a null value.
    *
    * @param rate MPXRate value
    * @return The cost component of an MPXRate
    */
   private double getRateCost (MPXRate rate)
   {
      double amount = 0;

      if (rate != null)
      {
         amount = rate.getAmount();
      }

      return (amount);
   }

   /**
    * This method converts an hourly rate expressed as a BigDecimal into
    * an MPXRate object, handling the case where the rate value is null.
    *
    * @param value Hourly rate
    * @return MPXRate instance
    */
   private MPXRate getHourlyRate (BigDecimal value)
   {
      MPXRate result = null;

      if (value != null)
      {
         result = new MPXRate (value, TimeUnit.HOURS);
      }

      return (result);
   }

   /**
    * This method converts an MPXDuration value into a duration
    * expressed in minutes.
    *
    * @todo This conversion does not use a calendar and is therefore arbitrary.
    * @param duration MPXDuration value
    * @return Duration value in minutes
    */
   private double getDurationInMinutes (MPXDuration duration)
   {
      double result = 0;

      if (duration != null)
      {
         result = duration.getDuration();

         switch (duration.getType())
         {
            case TimeUnit.HOURS:
            case TimeUnit.ELAPSED_HOURS:
            {
               result *= 60;
               break;
            }

            case TimeUnit.DAYS:
            case TimeUnit.ELAPSED_DAYS:
            {
               result *= (60 * 8);
               break;
            }

            case TimeUnit.WEEKS:
            case TimeUnit.ELAPSED_WEEKS:
            {
               result *= (60 * 8 * 5);
               break;
            }

            case TimeUnit.MONTHS:
            case TimeUnit.ELAPSED_MONTHS:
            {
               result *= (60 * 8 * 5 * 4);
               break;
            }

            case TimeUnit.YEARS:
            case TimeUnit.ELAPSED_YEARS:
            {
               result *= (60 * 8 * 5 * 52);
               break;
            }
         }
      }

      return (result);
   }

   /**
    * This is a convenience method provided to allow the contents of the MSPDI
    * file to be written to a file specified by the File object passed as
    * a parameter.
    *
    * @param out destination output file
    * @throws IOException thrown on failure to write to the file
    */
   public void write (File out)
      throws IOException
   {
      FileOutputStream fos = new FileOutputStream (out);
      write (fos);
      fos.flush();
      fos.close();
   }

   /**
    * This is a convenience method provided to allow the contents of the MSPDI
    * file to be written to a file specified by the file name passed as
    * a parameter.
    *
    * @param file destination output file
    * @throws IOException thrown on failure to write to the file
    */
   public void write (String file)
      throws IOException
   {
      FileOutputStream fos = new FileOutputStream (file);
      write (fos);
      fos.flush();
      fos.close();
   }

   /**
    * This is the main output method provided by this class. It allows
    * project data to be written to an output stream as XML data formatted
    * according to the MSPDI XML Schema.
    *
    * @param stream Output stream
    *
    * @throws IOException on write errors
    */
   public void write (OutputStream stream)
      throws IOException
   {
      try
      {
         //
         // Note that the line commented out below is the normal way to
         // initialise the context. A workaround has been applied to this
         // code to solve a problem in Sun's Beta 1.0 Reference Implementation
         // of JAXB. See the URL below for details.
         //
         // http://forum.java.sun.com/thread.jsp?forum=34&thread=320813
         //

         //JAXBContext context = JAXBContext.newInstance ("com.tapsterrock.mspdi.schema");
         JAXBContext context = JAXBContext.newInstance ("com.tapsterrock.mspdi.schema", new JAXBClassLoader(Thread.currentThread().getContextClassLoader()));
         Marshaller marshaller = context.createMarshaller();
         marshaller.setProperty (Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);

         HashMap calendarMap = new HashMap();

         Project project = ObjectFactory.createProject();

         writeCurrencySettings (project);
         writeDateTimeSettings (project);
         writeDefaultSettings (project);
         writeProjectHeader (project);
         writeCalendars (project, calendarMap);
         writeResources (project, calendarMap);
         writeTasks (project);
         writeAssignments (project);

         if (m_compatible == true)
         {
            stream = new CompatabilityOutputStream (stream);
         }

         marshaller.marshal (project, stream);
      }

      catch (JAXBException ex)
      {
         throw new IOException (ex.toString());
      }
   }

   /**
    * This method writes currency settings data to an MSPDI file.
    *
    * @param project Root node of the MSPDI file
    */
   private void writeCurrencySettings (Project project)
   {
      CurrencySettings currency = getCurrencySettings();
      project.setCurrencyDigits(BigInteger.valueOf (currency.getCurrencyDigitsValue()));
      project.setCurrencySymbol(currency.getCurrencySymbol());
      project.setCurrencySymbolPosition(getXmlSymbolPosition (currency.getSymbolPositionValue()));
   }

   /**
    * This method writes date and time settings data to an MSPDI file.
    *
    * @param project Root node of the MSPDI file
    */
   private void writeDateTimeSettings (Project project)
   {
      DateTimeSettings settings = getDateTimeSettings();
      project.setDefaultFinishTime(getCalendar (settings.getDefaultEndTimeAsDate()));
      project.setDefaultStartTime(getCalendar (settings.getDefaultStartTimeAsDate()));
   }


   /**
    * This method writes default settings data to an MSPDI file.
    *
    * @param project Root node of the MSPDI file
    */
   private void writeDefaultSettings (Project project)
   {
      DefaultSettings settings = getDefaultSettings();
      project.setDurationFormat(getXmlDurationUnits(settings.getDefaultDurationUnitsValue()));
      project.setDefaultOvertimeRate((float)getRateCost(settings.getDefaultOvertimeRate()));
      project.setDefaultStandardRate((float)getRateCost(settings.getDefaultStandardRate()));
      project.setWorkFormat(getXmlWorkUnits(settings.getDefaultWorkUnitsValue()));
      project.setSplitsInProgressTasks(settings.getSplitInProgressTasksValue());
      project.setTaskUpdatesResource(settings.getUpdatingTaskStatusUpdatesResourceStatusValue());
   }

   /**
    * This method writes project header data to an MSPDI file.
    *
    * @param project Root node of the MSPDI file
    */
   private void writeProjectHeader (Project project)
   {
      ProjectHeader header = getProjectHeader ();

      project.setAuthor(header.getAuthor());
      project.setCompany(header.getCompany());
      project.setCurrentDate(getCalendar(header.getCurrentDate()));
      project.setFinishDate(getCalendar(header.getFinishDate()));
      project.setManager(header.getManager());
      project.setStartDate(getCalendar(header.getStartDate()));
      project.setSubject(header.getSubject());
   }

   /**
    * This method writes calandar data to an MSPDI file.
    *
    * @param project Root node of the MSPDI file
    * @param map Map of calendar UIDs to names
    * @throws JAXBException on xml creation errors
    */
   private void writeCalendars (Project project, HashMap map)
      throws JAXBException
   {
      //
      // Create the new calendar list
      //
      Project.CalendarsType calendars = ObjectFactory.createProjectTypeCalendarsType();
      project.setCalendars (calendars);
      List calendar = calendars.getCalendar();

      //
      // Process each calendar in turn
      //
      List list = getBaseCalendars ();
      Iterator iter = list.iterator();
      BaseCalendar bc;
      int uid = 0;
      ObjectFactory.createProjectTypeCalendarsTypeCalendarType();

      while (iter.hasNext() == true)
      {
         ++uid;
         bc = (BaseCalendar)iter.next();
         map.put(bc.getName(), new Integer (uid));
         calendar.add (writeCalendar (bc, uid));
      }
   }

   /**
    * This method writes data for a single calandar to an MSPDI file.
    *
    * @param bc Base calendar data
    * @param uid Unique ID for this calendar
    * @return New MSPDI calendar instance
    * @throws JAXBException on xml creation errors
    */
   private Project.CalendarsType.CalendarType writeCalendar (BaseCalendar bc, int uid)
      throws JAXBException
   {
      //
      // Create a calendar
      //
      Project.CalendarsType.CalendarType calendar = ObjectFactory.createProjectTypeCalendarsTypeCalendarType();
      calendar.setUID(BigInteger.valueOf(uid));
      calendar.setIsBaseCalendar(true);
      if (bc.getName().equalsIgnoreCase("Standard") == true)
      {
         calendar.setBaseCalendarUID(BigInteger.valueOf(-1));
      }
      else
      {
         calendar.setBaseCalendarUID(BigInteger.valueOf(uid));
      }
      calendar.setName(bc.getName());

      //
      // Create a list of normal days
      //
      Project.CalendarsType.CalendarType.WeekDaysType days = ObjectFactory.createProjectTypeCalendarsTypeCalendarTypeWeekDaysType();
      Project.CalendarsType.CalendarType.WeekDaysType.WeekDayType.WorkingTimesType times;
      Project.CalendarsType.CalendarType.WeekDaysType.WeekDayType.WorkingTimesType.WorkingTimeType time;
      BaseCalendarHours bch;
      List timesList;

      calendar.setWeekDays (days);
      List dayList = days.getWeekDay();

      Project.CalendarsType.CalendarType.WeekDaysType.WeekDayType day;
      int dayType;
      int loop;
      boolean working;

      for (loop=1; loop < 8; loop++)
      {
         dayType = loop - 1;
         if (dayType == 0)
         {
            dayType = 7;
         }

         working = bc.isWorkingDay(loop);

         day = ObjectFactory.createProjectTypeCalendarsTypeCalendarTypeWeekDaysTypeWeekDayType();
         dayList.add(day);
         day.setDayType(BigInteger.valueOf(dayType));
         day.setDayWorking(working);
         if (working == true)
         {
            times = ObjectFactory.createProjectTypeCalendarsTypeCalendarTypeWeekDaysTypeWeekDayTypeWorkingTimesType ();
            day.setWorkingTimes(times);
            timesList = times.getWorkingTime();

            bch = bc.getBaseCalendarHours (loop);
            if (bch != null)
            {
               time = ObjectFactory.createProjectTypeCalendarsTypeCalendarTypeWeekDaysTypeWeekDayTypeWorkingTimesTypeWorkingTimeType ();
               timesList.add (time);

               time.setFromTime(getCalendar(bch.getFromTime1()));
               time.setToTime(getCalendar(bch.getToTime1()));

               time = ObjectFactory.createProjectTypeCalendarsTypeCalendarTypeWeekDaysTypeWeekDayTypeWorkingTimesTypeWorkingTimeType ();
               timesList.add (time);

               time.setFromTime(getCalendar(bch.getFromTime2()));
               time.setToTime(getCalendar(bch.getToTime2()));

               time = ObjectFactory.createProjectTypeCalendarsTypeCalendarTypeWeekDaysTypeWeekDayTypeWorkingTimesTypeWorkingTimeType ();
               timesList.add (time);

               time.setFromTime(getCalendar(bch.getFromTime3()));
               time.setToTime(getCalendar(bch.getToTime3()));
            }
         }
      }

      //
      // Create a list of exceptions
      //
      List exceptions = bc.getBaseCalendarExceptions ();
      Iterator iter = exceptions.iterator();
      BaseCalendarException exception;
      Project.CalendarsType.CalendarType.WeekDaysType.WeekDayType.TimePeriodType period;

      while (iter.hasNext() == true)
      {
         exception = (BaseCalendarException)iter.next();
         working = exception.getWorkingValue();

         day = ObjectFactory.createProjectTypeCalendarsTypeCalendarTypeWeekDaysTypeWeekDayType();
         dayList.add(day);
         day.setDayType(BIGINTEGER_ZERO);
         day.setDayWorking(working);

         period = ObjectFactory.createProjectTypeCalendarsTypeCalendarTypeWeekDaysTypeWeekDayTypeTimePeriodType();
         day.setTimePeriod(period);
         period.setFromDate(getCalendar(exception.getFromDate()));
         period.setToDate(getCalendar (exception.getToDate()));

         if (working == true)
         {
            times = ObjectFactory.createProjectTypeCalendarsTypeCalendarTypeWeekDaysTypeWeekDayTypeWorkingTimesType ();
            day.setWorkingTimes(times);
            timesList = times.getWorkingTime();

            time = ObjectFactory.createProjectTypeCalendarsTypeCalendarTypeWeekDaysTypeWeekDayTypeWorkingTimesTypeWorkingTimeType ();
            timesList.add (time);

            time.setFromTime(getCalendar(exception.getFromTime1()));
            time.setToTime(getCalendar(exception.getToTime1()));

            time = ObjectFactory.createProjectTypeCalendarsTypeCalendarTypeWeekDaysTypeWeekDayTypeWorkingTimesTypeWorkingTimeType ();
            timesList.add (time);

            time.setFromTime(getCalendar(exception.getFromTime2()));
            time.setToTime(getCalendar(exception.getToTime2()));

            time = ObjectFactory.createProjectTypeCalendarsTypeCalendarTypeWeekDaysTypeWeekDayTypeWorkingTimesTypeWorkingTimeType ();
            timesList.add (time);

            time.setFromTime(getCalendar(exception.getFromTime3()));
            time.setToTime(getCalendar(exception.getToTime3()));
         }
      }

      return (calendar);
   }

   /**
    * This method writes resource data to an MSPDI file.
    *
    * @param project Root node of the MSPDI file
    * @param calendarMap Map of calendar names to UIDs
    * @throws JAXBException on xml creation errors
    */
   private void writeResources (Project project, HashMap calendarMap)
      throws JAXBException
   {
      Project.ResourcesType resources = ObjectFactory.createProjectTypeResourcesType();
      project.setResources(resources);
      List list = resources.getResource();

      Iterator iter = getAllResources().iterator();
      while (iter.hasNext() == true)
      {
         list.add (writeResource ((Resource)iter.next(), calendarMap));
      }
   }

   /**
    * This method writes data for a single resource to an MSPDI file.
    *
    * @param mpx Resource data
    * @param calendarMap Map of calendar names to UIDs
    * @return New MSPDI resource instance
    * @throws JAXBException on xml creation errors
    */
   private Project.ResourcesType.ResourceType writeResource (Resource mpx, HashMap calendarMap)
      throws JAXBException
   {
      Project.ResourcesType.ResourceType xml = ObjectFactory.createProjectTypeResourcesTypeResourceType();
      Integer calendarUID = (Integer)calendarMap.get(mpx.getBaseCalendar());
      if (calendarUID != null)
      {
         xml.setCalendarUID(BigInteger.valueOf(calendarUID.longValue()));
      }

      xml.setAccrueAt(BigInteger.valueOf(mpx.getAccrueAtValue()));
      xml.setActualCost(getXmlCurrency (mpx.getActualCost()));
      xml.setActualOvertimeCost(getXmlCurrency(mpx.getActualOvertimeCost()));
      xml.setActualWork(getDuration (mpx.getActualWork()));
      xml.setCode(mpx.getCode());
      xml.setCost(getXmlCurrency(mpx.getCost()));
      xml.setCostPerUse(getXmlCurrency(mpx.getCostPerUse()));
      xml.setCostVariance((float)(mpx.getCostVarianceValue()*100));
      xml.setEmailAddress(mpx.getEmailAddress());
      xml.setGroup(mpx.getGroup());
      xml.setID(BigInteger.valueOf(mpx.getIDValue()));
      xml.setInitials(mpx.getInitials());
      xml.setMaxUnits((float)(mpx.getMaxUnitsValue()/100));
      xml.setName(mpx.getName());
      xml.setNotes(mpx.getNotes());
      xml.setOvertimeCost(getXmlCurrency(mpx.getOvertimeCost()));
      xml.setOvertimeRate(new BigDecimal (getRateCost (mpx.getOvertimeRate())));
      xml.setOvertimeWork(getDuration (mpx.getOvertimeWork()));
      xml.setPeakUnits((float)(mpx.getPeakValue()/100));
      xml.setPercentWorkComplete(BigInteger.valueOf((long)mpx.getPercentageWorkCompleteValue()));
      xml.setRegularWork(getDuration(mpx.getRegularWork()));
      xml.setRemainingCost(getXmlCurrency(mpx.getRemainingCost()));
      xml.setRemainingOvertimeCost(getXmlCurrency(mpx.getRemainingOvertimeCost()));
      xml.setRemainingWork(getDuration(mpx.getRemainingWork()));
      xml.setStandardRate(new BigDecimal (getRateCost (mpx.getStandardRate())));
      xml.setUID(BigInteger.valueOf(mpx.getUniqueIDValue()));
      xml.setWork(getDuration(mpx.getWork()));
      xml.setWorkVariance((float)getDurationInMinutes(mpx.getWorkVariance())*1000);

      return (xml);
   }

   /**
    * This method writes task data to an MSPDI file.
    *
    * @param project Root node of the MSPDI file
    * @throws JAXBException on xml creation errors
    */
   private void writeTasks (Project project)
      throws JAXBException
   {
      Project.TasksType tasks = ObjectFactory.createProjectTypeTasksType();
      project.setTasks (tasks);
      List list = tasks.getTask();

      Iterator iter = getAllTasks().iterator();
      while (iter.hasNext() == true)
      {
         list.add (writeTask ((Task)iter.next()));
      }
   }


   /**
    * This method writes data for a single task to an MSPDI file.
    *
    * @param mpx Task data
    * @return MSPDI task instance
    * @throws JAXBException on xml creation errors
    */
   private Project.TasksType.TaskType writeTask (Task mpx)
      throws JAXBException
   {
      Project.TasksType.TaskType xml = ObjectFactory.createProjectTypeTasksTypeTaskType();
      DateTimeSettings settings = getDateTimeSettings();
      int defaultStartTime = settings.getDefaultStartTimeValue();
      int defaultFinishTime = settings.getDefaultEndTimeValue();
            
      xml.setActualCost(getXmlCurrency(mpx.getActualCost()));
      xml.setActualDuration(getDuration(mpx.getActualDuration()));
      xml.setActualFinish(getCalendar(mpx.getActualFinish()));
      xml.setActualStart(getCalendar(mpx.getActualStart()));
      xml.setActualWork(getDuration(mpx.getActualWork()));
      xml.setBCWP((float)mpx.getBCWPValue());
      xml.setBCWS((float)mpx.getBCWSValue());
      xml.setConstraintDate(getCalendar(mpx.getConstraintDate()));
      xml.setConstraintType(BigInteger.valueOf(mpx.getConstraintTypeValue()));
      xml.setContact(mpx.getContact());
      xml.setCost(getXmlCurrency(mpx.getCost()));
      xml.setCreateDate(getCalendar(mpx.getCreated()));
      xml.setCritical(mpx.getCriticalValue());
      xml.setCV((float)(mpx.getCVValue()*100));
      xml.setDeadline(getCalendar(mpx.getDeadline()));
      xml.setDuration(getDuration(mpx.getDuration()));
      xml.setDurationFormat(getDurationFormat(mpx.getDuration()));
      xml.setEarlyFinish(getCalendar(mpx.getEarlyFinish()));
      xml.setEarlyStart(getCalendar(mpx.getEarlyStart()));
      xml.setEffortDriven(mpx.getEffortDriven());
      xml.setEstimated(mpx.getEstimated());
      
      Date finishDate = mpx.getFinish();
      if (finishDate != null)
      {                  
         long finishTime = finishDate.getTime();
         Calendar cal = Calendar.getInstance();
         cal.setTime(finishDate);

         if (cal.get(Calendar.HOUR_OF_DAY) == 0 && cal.get(Calendar.MINUTE) == 0)
         {
            finishDate = new Date(finishTime + (defaultFinishTime * MS_PER_MINUTE));
         }
         
         xml.setFinish(getCalendar(finishDate));
      }
      
      xml.setFinishVariance(BigInteger.valueOf((long)getDurationInMinutes(mpx.getFinishVariance())*1000));
      xml.setFixedCost((float)(mpx.getFixedCostValue()*100));
      xml.setFreeSlack(BigInteger.valueOf((long)getDurationInMinutes(mpx.getFreeSlack())*1000));
      xml.setHideBar(mpx.getHideBarValue());
      xml.setID(BigInteger.valueOf(mpx.getIDValue()));
      xml.setLateFinish(getCalendar(mpx.getLateFinish()));
      xml.setLateStart(getCalendar(mpx.getLateStart()));
      xml.setMilestone(mpx.getMilestoneValue());
      xml.setName(mpx.getName());
      xml.setNotes(mpx.getNotes());
      xml.setOutlineLevel(BigInteger.valueOf(mpx.getOutlineLevelValue()));
      xml.setOutlineNumber(mpx.getOutlineNumber());
      xml.setOvertimeCost(getXmlCurrency(mpx.getOvertimeCost()));
      xml.setPercentComplete(BigInteger.valueOf((long)mpx.getPercentageCompleteValue()));
      xml.setPercentWorkComplete(BigInteger.valueOf((long)mpx.getPercentageWorkCompleteValue()));
      xml.setPriority(getXmlPriority(mpx.getPriority()));
      xml.setRecurring((mpx.getRecurringTask()!=null));
      xml.setRemainingCost(getXmlCurrency(mpx.getRemainingCost()));

      if (m_compatible == true && mpx.getRemainingDuration() == null)
      {
         MPXDuration duration = mpx.getDuration();

         if (duration != null)
         {
            double amount = duration.getDuration();
            amount -= ((amount * mpx.getPercentageCompleteValue())/100);
            xml.setRemainingDuration(getDuration(new MPXDuration (amount, duration.getType())));
         }
      }
      else
      {
         xml.setRemainingDuration(getDuration(mpx.getRemainingDuration()));
      }

      xml.setRemainingWork(getDuration(mpx.getRemainingWork()));
      xml.setResume(getCalendar(mpx.getResume()));
      xml.setRollup(mpx.getRollupValue());

      Date startDate = mpx.getStart();
      if (startDate != null)
      {                  
         long startTime = startDate.getTime();
         Calendar cal = Calendar.getInstance();
         cal.setTime(startDate);

         if (cal.get(Calendar.HOUR_OF_DAY) == 0 && cal.get(Calendar.MINUTE) == 0)
         {
            startDate = new Date(startTime + (defaultStartTime * MS_PER_MINUTE));
         }
         
         xml.setStart(getCalendar(startDate));
      }


      xml.setStartVariance(BigInteger.valueOf((long)getDurationInMinutes(mpx.getStartVariance())*1000));
      xml.setStop(getCalendar (mpx.getStop()));
      xml.setSummary(mpx.getSummaryValue());
      xml.setTotalSlack(BigInteger.valueOf((long)getDurationInMinutes(mpx.getTotalSlack())*1000));
		xml.setType(BigInteger.valueOf((long)mpx.getType()));      
      xml.setUID(BigInteger.valueOf(mpx.getUniqueIDValue()));
      xml.setWBS(mpx.getWBS());
      xml.setWork(getDuration(mpx.getWork()));
      xml.setWorkVariance((float)getDurationInMinutes(mpx.getWorkVariance())*1000);

      //
      // Default values for fields not represented in the MPX data structures
      //
      xml.setIsNull(false);
      xml.setResumeValid(false);
      xml.setOverAllocated(false);
      xml.setEstimated(false);
      xml.setIsSubproject(false);
      xml.setIsSubprojectReadOnly(false);
      xml.setExternalTask(false);
      xml.setFixedCostAccrual("2");
      xml.setOvertimeWork(ZERO_DURATION);
      xml.setActualOvertimeCost(BIGDECIMAL_ZERO);
      xml.setActualOvertimeWork(ZERO_DURATION);
      xml.setCalendarUID(BigInteger.valueOf(-1));
      xml.setRegularWork(getDuration(mpx.getWork()));
      xml.setRemainingOvertimeCost(BIGDECIMAL_ZERO);
      xml.setRemainingOvertimeWork(ZERO_DURATION);
      xml.setACWP(0);
      xml.setLevelAssignments(true);
      xml.setLevelingCanSplit(true);
      xml.setLevelingDelay(BIGINTEGER_ZERO);
      xml.setLevelingDelayFormat(BigInteger.valueOf(8));
      xml.setIgnoreResourceCalendar(false);
      xml.setPhysicalPercentComplete(BIGINTEGER_ZERO);
      xml.setEarnedValueMethod(BIGINTEGER_ZERO);

      writePredecessors (xml, mpx);

      return (xml);
   }


   /**
    * This method writes predecessor data to an MSPDI file.
    * We have to deal with a slight anomaly in this method that is introduced
    * by the MPX file format. It would be possible for someone to create an
    * MPX file with both the predecessor list and the unique ID predecessor
    * list populated... which means that we must process both and avoid adding
    * duplicate predecessors. Also interesting to note is that MSP98 populates
    * the predecessor list, not the unique ID predecessor list, as you might
    * expect.
    *
    * @param xml MSPDI task data
    * @param mpx MPX task data
    * @throws JAXBException on xml creation errors
    */
   private void writePredecessors (Project.TasksType.TaskType xml, Task mpx)
      throws JAXBException
   {
      TreeSet set = new TreeSet ();
      int taskID;
      Relation rel;
      List list = xml.getPredecessorLink();
      Iterator iter;

      //
      // Process the list of predecessors specified by Unique ID
      //
      RelationList predecessors = mpx.getUniqueIDPredecessors();
      if (predecessors != null)
      {
         iter = predecessors.iterator();
         while (iter.hasNext() == true)
         {
            rel = (Relation)iter.next();
            taskID = rel.getTaskIDValue();
            set.add(new Integer(taskID));
            list.add (writePredecessor (taskID, rel.getType(), rel.getDuration()));
         }
      }

      //
      // Process the list of predecessors specified by ID.
      // Note that this code ensures that if both lists are populated,
      // we avoid creating duplicate links.
      //
      predecessors = mpx.getPredecessors();
      if (predecessors != null)
      {
         Task task;
         iter = predecessors.iterator();
         while (iter.hasNext() == true)
         {
            rel = (Relation)iter.next();
            task = getTaskByID(rel.getTaskIDValue());
            if (task != null)
            {
               taskID = task.getUniqueIDValue();
               if (set.contains(new Integer(taskID)) == false)
               {
                  list.add (writePredecessor (taskID, rel.getType(), rel.getDuration()));
               }
            }
         }
      }
   }

   /**
    * This method writes a single predecessor link to the MSPDI file.
    *
    * @param taskID The task UID
    * @param type The predecessor type
    * @param lag The lag duration
    * @return A new link to be added to the MSPDI file
    * @throws JAXBException on xml creation errors
    */
   private Project.TasksType.TaskType.PredecessorLinkType writePredecessor (int taskID, int type, MPXDuration lag)
      throws JAXBException
   {
      Project.TasksType.TaskType.PredecessorLinkType link = ObjectFactory.createProjectTypeTasksTypeTaskTypePredecessorLinkType();

      link.setPredecessorUID (BigInteger.valueOf(taskID));
      link.setType (BigInteger.valueOf(type));

      if (lag != null && lag.getDuration() != 0)
      {
         link.setLinkLag(BigInteger.valueOf((long)getDurationInMinutes(lag)*10));
         link.setLagFormat(getXmlDurationUnits (lag.getType()));
      }

      return (link);
   }


   /**
    * This method writes assignment data to an MSPDI file.
    *
    * @param project Root node of the MSPDI file
    * @throws JAXBException on xml creation errors
    */
   private void writeAssignments (Project project)
      throws JAXBException
   {
      int uid = 0;
      Project.AssignmentsType assignments = ObjectFactory.createProjectTypeAssignmentsType();
      project.setAssignments(assignments);
      List list = assignments.getAssignment();
      Iterator iter = getAllResourceAssignments().iterator();
      while (iter.hasNext() == true)
      {
         list.add(writeAssignment ((ResourceAssignment)iter.next(), uid));
         ++uid;
      }
   }


   /**
    * This method writes data for a single assignment to an MSPDI file.
    *
    * @param mpx Resource assignment data
    * @param uid Unique ID for the new assignment
    * @return New MSPDI assignment instance
    * @throws JAXBException on xml creation errors
    */
   private Project.AssignmentsType.AssignmentType writeAssignment (ResourceAssignment mpx, int uid)
      throws JAXBException
   {
      Project.AssignmentsType.AssignmentType xml = ObjectFactory.createProjectTypeAssignmentsTypeAssignmentType();

      xml.setActualCost(getXmlCurrency (mpx.getActualCost()));
      xml.setActualWork(getDuration (mpx.getActualWork()));
      xml.setCost(getXmlCurrency (mpx.getCost()));
      xml.setDelay(BigInteger.valueOf((long)getDurationInMinutes(mpx.getDelay())*1000));
      xml.setFinish(getCalendar(mpx.getFinish()));
      xml.setOvertimeWork(getDuration(mpx.getOvertimeWork()));
      xml.setResourceUID(BigInteger.valueOf(mpx.getResourceUniqueIDValue()));
      xml.setStart(getCalendar (mpx.getStart()));
      xml.setTaskUID(BigInteger.valueOf(mpx.getTask().getUniqueIDValue()));
      xml.setUID(BigInteger.valueOf(uid));
      xml.setUnits((float)mpx.getUnitsValue()/100);
      xml.setWork(getDuration (mpx.getWork()));

      return (xml);
   }



   /**
    * This class is used to provide a workaround for a bug in the Beta 1.0
    * release of Sun's JAXB Reference Implementation. See the URL below
    * for details.
    *
    * http://forum.java.sun.com/thread.jsp?forum=34&thread=320813
    */
   private class JAXBClassLoader extends ClassLoader
   {
      /**
       * Constructor. Takes a reference to the parent class loader.
       *
       * @param aClassLoader parent class loader
       */
      public JAXBClassLoader (ClassLoader aClassLoader)
      {
         super (aClassLoader);
      }

      /**
       * Overridden method used to correct bug in JAXB 1.0 Beta
       * implementation where the code uses the wrong separator character.
       *
       * @param name Resource name
       * @return URL for requested resource
       */
      public URL getResource (String name)
      {
         return (super.getResource(name.replace('\\','/')));
      }
   }

   /**
    * This class is used to work around a number of problems with
    * Microsoft's XML implementation as used in Microsoft Project 2002.
    * Essentially this class implements a very simple find and replace
    * mechanism, allowing the output stream to be filtered on the fly
    * to change the contents.
    */
   private class CompatabilityOutputStream extends OutputStream
   {
      /**
       * Constructor. Takes the original output stream as an argument.
       *
       * @param parent Original output stream.
       */
      public CompatabilityOutputStream (OutputStream parent)
      {
         m_parent = parent;
         int max = 0;
         for (int loop=0; loop < m_find.length; loop++)
         {
            if (m_find[loop].length > max)
            {
               max = m_find[loop].length;
            }
         }
         m_buffer = new byte[max];
      }

      /**
       * This method writes a byte to the output stream. All of
       * the find and replace filtering takes place in this method.
       *
       * @param b Input byte
       * @throws IOException on write error
       */
      public void write (int b)
         throws IOException
      {
         if (m_match == -1)
         {
            for (int loop=0; loop < m_find.length; loop++)
            {
               if (b == m_find[loop][0])
               {
                  m_match = loop;
                  break;
               }
            }

            if (m_match != -1)
            {
               m_buffer[0] = (byte)b;
               m_index = 1;
            }
            else
            {
               m_parent.write (b);
            }
         }
         else
         {
            int find = m_find[m_match][m_index];
            
            if ((m_match > 0 && find == '?') || b == find)
            {
               m_buffer[m_index] = (byte)b;
               ++m_index;
               if (m_index == m_find[m_match].length)
               {
                  if (m_replace[m_match] != null)
                  {
                     m_parent.write(m_replace[m_match].getBytes());
                  }
                  m_match = -1;
               }
            }
            else
            {
               m_match = -1;
               m_parent.write(m_buffer, 0, m_index);
               write (b);
            }
         }
      }

      /**
       * This method passes the call on to the original output stream.
       *
       * @throws IOException on write error
       */
      public void flush()
         throws IOException
      {
         m_parent.flush();
      }

      /**
       * This method passes the call on to the original output stream.
       *
       * @throws IOException on write error
       */
      public void close()
         throws IOException
      {
         m_parent.close ();
      }

      private OutputStream m_parent;
      private int m_match = -1;
      private byte[] m_buffer;
      private int m_index = 0;

      private byte[][] m_find =
      {
         "ns1:".getBytes(),
         ":ns1".getBytes(),
         ".000".getBytes(),
         "+??:??<".getBytes(),
         "-??:??<".getBytes(),
         "true<".getBytes(),
         "false<".getBytes()
      };

      private String[] m_replace =
      {
         null,
         null,
         null,
         "<",
         "<",
         "1<",
         "0<"
      };
   }

   private boolean m_compatible = true;

   private static final String ZERO_DURATION = "PT0H0M0S";
   private static final BigDecimal BIGDECIMAL_ZERO = BigDecimal.valueOf(0);
   private static final BigInteger BIGINTEGER_ZERO = BigInteger.valueOf(0);
   private static final long MS_PER_DAY = 1000 * 60 * 60 * 24;
   private static final int MS_PER_MINUTE = 1000 * 60;
}

